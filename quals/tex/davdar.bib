@inproceedings{cousot:1977:ai,
    address = {New York, NY, USA},
    author = {Cousot, Patrick and Cousot, Radhia},
    booktitle = {POPL '77: Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
    citeulike-article-id = {2631924},
    keywords = {abstract, interpretation},
    pages = {238--252},
    posted-at = {2014-04-17 00:50:13},
    priority = {2},
    publisher = {ACM},
    title = {Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints},
    year = {1977}
}

@book{nielson:2004:program-analysis,
    abstract = {{Program analysis concerns static techniques for computing reliable approximate information about the dynamic behaviour of programs. Applications include compilers (for code improvement), software validation (for detecting errors in algorithms or breaches of security) and transformations between data representation (for solving problems such as the Y2K problem). This book is unique in giving an overview of the four major approaches to program analysis: data flow analysis, constraint based analysis, abstract interpretation, and type and effect systems. The presentation demonstrates the extensive similarities between the approaches; this will aid the reader in choosing the right approach and in enhancing it with insights from the other approaches. The book covers basic semantic properties as well as more advanced algorithmic techniques. The book is aimed at M.Sc. and Ph.D. students but will be valuable also for experienced researchers and professionals.}},
    author = {Nielson, Flemming and Nielson, Hanne R. and Hankin, Chris},
    citeulike-article-id = {5709622},
    citeulike-linkout-0 = {http://books.google.de/books?id=RLjt0xSj8DcC\&\#38;printsec=frontcover\&\#38;source=gbs\_navlinks\_s\#v=onepage\&\#38;q=\&\#38;f=false},
    howpublished = {Hardcover},
    month = dec,
    posted-at = {2014-04-16 18:58:46},
    priority = {2},
    publisher = {Springer},
    title = {Principles of Program Analysis},
    url = {http://books.google.de/books?id=RLjt0xSj8DcC\&printsec=frontcover\&source=gbs\_navlinks\_s\#v=onepage\&q=\&f=false},
    year = {2004}
}

@phdthesis{shivers:1991:cfa,
    abstract = {Programs written in powerful, higher-order languages like Scheme, {ML}, and Common Lisp should run as fast as their {FORTRAN} and C counterparts. They should, but they don't. A major reason is the level of optimisation applied to these two classes of languages. Many {FORTRAN} and C compilers employ an arsenal of sophisticated global optimisations that depend upon data-ﬂow analysis: common-subexpression elimination, loop-invariant detection, induction-variable elimination, and many, many more. Compilers for higher- order languages do not provide these optimisations. Without them, Scheme, {LISP} and {ML} compilers are doomed to produce code that runs slower than their {FORTRAN} and C counterparts. The problem is the lack of an explicit control-ﬂow graph at compile time, something which traditional data-ﬂow analysis techniques require. In this dissertation, I present a technique for recovering the control-ﬂow graph of a Scheme program at compile time. I give examples of how this information can be used to perform several data-ﬂow analysis optimisations, including copy propagation, induction-variable elimination, useless-variable elimination, and type recovery. The analysis is deﬁned in terms of a non-standard semantic interpretation. The denotational semantics is carefully developed, and several theorems establishing the correctness of the semantics and the implementing algorithms are proven.},
    address = {Pittsburgh, PA, USA},
    author = {Shivers, Olin G.},
    citeulike-article-id = {82936},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=124950},
    keywords = {abstract-interpretation, cfa},
    posted-at = {2014-04-16 18:56:32},
    priority = {2},
    publisher = {Carnegie Mellon University},
    school = {Carnegie Mellon University},
    title = {{Control-Flow} Analysis of {Higher-Order} Languages},
    url = {http://portal.acm.org/citation.cfm?id=124950},
    year = {1991}
}

@incollection{cousot:1999:calculational,
    author = {Cousot, Patrick},
    booktitle = {Calculational System Design},
    citeulike-article-id = {6768482},
    editor = {Broy, M. and Steinbr\"{u}ggen, R.},
    posted-at = {2014-04-16 18:44:12},
    priority = {2},
    publisher = {NATO ASI Series F. IOS Press, Amsterdam},
    title = {The Calculational Design of a Generic Abstract Interpreter},
    year = {1999}
}

@incollection{midtgaard:2008:calculational-cfa,
    abstract = {We present a derivation of a control-flow analysis by abstract interpretation. Our starting point is a transition system semantics defined as an abstract machine for a small functional language in continuation-passing style. We obtain a Galois connection for abstracting the machine states by composing Galois connections, most notable an independent-attribute Galois connection on machine states and a Galois connection induced by a closure operator associated with a constituent-parts relation on environments. We calculate abstract transfer functions by applying the state abstraction to the collecting semantics, resulting in a novel characterization of demand-driven {0-CFA}.},
    address = {Berlin, Heidelberg},
    author = {Midtgaard, Jan and Jensen, Thomas},
    booktitle = {Static Analysis},
    chapter = {23},
    citeulike-article-id = {10793227},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-69166-2\_23},
    citeulike-linkout-1 = {http://www.springerlink.com/content/06710k86j0638054},
    doi = {10.1007/978-3-540-69166-2\_23},
    editor = {Alpuente, Mar\'{\i}a and Vidal, Germ\'{a}n},
    isbn = {978-3-540-69163-1},
    issn = {0302-9743},
    keywords = {abstract-interpretation, flow-analysis},
    pages = {347--362},
    posted-at = {2014-04-16 18:33:09},
    priority = {2},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {A Calculational Approach to {Control-Flow} Analysis by Abstract Interpretation Static Analysis},
    url = {http://dx.doi.org/10.1007/978-3-540-69166-2\_23},
    volume = {5079},
    year = {2008}
}

@article{van-horn:2010:aam,
    abstract = {We describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well-established abstract machines. To demonstrate the technique and support our claim, we transform the {CEK} machine of Felleisen and Friedman, a lazy variant of Krivine's machine, and the stack-inspecting {CM} machine of Clements and Felleisen into abstract interpretations of themselves. The resulting analyses bound temporal ordering of program events; predict return-flow and stack-inspection behavior; and approximate the flow and evaluation of by-need parameters. For all of these machines, we find that a series of well-known concrete machine refactorings, plus a technique we call store-allocated continuations, leads to machines that abstract into static analyses simply by bounding their stores. We demonstrate that the technique scales up uniformly to allow static analysis of realistic language features, including tail calls, conditionals, side effects, exceptions, first-class continuations, and even garbage collection.},
    address = {New York, NY, USA},
    author = {Van Horn, David and Might, Matthew},
    booktitle = {ICFP '10: Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {7956643},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1863543.1863553},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1863543.1863553},
    doi = {10.1145/1863543.1863553},
    isbn = {978-1-60558-794-3},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    location = {Baltimore, Maryland, USA},
    month = sep,
    number = {9},
    pages = {51--62},
    posted-at = {2014-04-16 18:32:17},
    priority = {2},
    publisher = {ACM},
    series = {ICFP '10},
    title = {Abstracting abstract machines},
    url = {http://dx.doi.org/10.1145/1863543.1863553},
    volume = {45},
    year = {2010}
}

@inproceedings{sergey:2013:mai,
    author = {Sergey, Ilya and Devriese, Dominique and Might, Matthew and Midtgaard, Jan and Darais, David and Clarke, Dave and Piessens, Frank},
    citeulike-article-id = {12208135},
    citeulike-linkout-0 = {http://matt.might.net/papers/sergey2013monalysis.pdf},
    journal = {Programming Language Design and Implementation},
    month = jun,
    posted-at = {2013-03-25 14:55:07},
    priority = {0},
    title = {Monadic Abstract Interpreters},
    url = {http://matt.might.net/papers/sergey2013monalysis.pdf},
    year = {2013}
}

@article{citeulike:12208106,
    author = {Flatt, Matthew and Culpepper, Ryan and Darais, David and Findler, Robert B.},
    citeulike-article-id = {12208106},
    citeulike-linkout-0 = {http://www.eecs.northwestern.edu/\~{}robby/pubs/papers/jfp2012-fcdf.pdf},
    journal = {Journal of Functional Programming},
    month = mar,
    number = {2},
    pages = {181--216},
    posted-at = {2013-03-25 14:46:26},
    priority = {0},
    title = {Macros that Work Together: Compile-time bindings, partial expansion, and definition contexts},
    url = {http://www.eecs.northwestern.edu/\~{}robby/pubs/papers/jfp2012-fcdf.pdf},
    volume = {22},
    year = {2012}
}

@article{citeulike:8133134,
    abstract = {We present two novel approaches to parsing context-free languages. The first
approach is based on an extension of Brzozowski's derivative from regular
expressions to context-free grammars. The second approach is based on a
generalization of the derivative to parser combinators. The payoff of these
techniques is a small (less than 250 lines of code), easy-to-implement parsing
library capable of parsing arbitrary context-free grammars into lazy parse
forests. Implementations for both Scala and Haskell are provided. Preliminary
experiments with {S-Expressions} parsed millions of tokens per second, which
suggests this technique is efficient enough for use in practice.},
    archivePrefix = {arXiv},
    author = {Might, Matthew and Darais, David},
    citeulike-article-id = {8133134},
    citeulike-linkout-0 = {http://arxiv.org/abs/1010.5023},
    citeulike-linkout-1 = {http://arxiv.org/pdf/1010.5023},
    day = {24},
    eprint = {1010.5023},
    month = oct,
    posted-at = {2013-03-25 14:39:13},
    priority = {0},
    title = {Yacc is dead},
    url = {http://arxiv.org/abs/1010.5023},
    year = {2010}
}

@article{citeulike:10870613,
    abstract = {We present a functional approach to parsing unrestricted context-free grammars based on Brzozowski's derivative of regular expressions. If we consider context-free grammars as recursive regular expressions, Brzozowski's equational theory extends without modification to context-free grammars (and it generalizes to parser combinators). The supporting actors in this story are three concepts familiar to functional programmers - laziness, memoization and fixed points; these allow Brzozowski's original equations to be transliterated into purely functional code in about 30 lines spread over three functions. Yet, this almost impossibly brief implementation has a drawback: its performance is sour - in both theory and practice. The culprit? Each derivative can double the size of a grammar, and with it, the cost of the next derivative. Fortunately, much of the new structure inflicted by the derivative is either dead on arrival, or it dies after the very next derivative. To eliminate it, we once again exploit laziness and memoization to transliterate an equational theory that prunes such debris into working code. Thanks to this compaction, parsing times become reasonable in practice. We equip the functional programmer with two equational theories that, when combined, make for an abbreviated understanding and implementation of a system for parsing context-free languages.},
    address = {New York, NY, USA},
    author = {Might, Matthew and Darais, David and Spiewak, Daniel},
    citeulike-article-id = {10870613},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2034801},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2034574.2034801},
    doi = {10.1145/2034574.2034801},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    month = sep,
    number = {9},
    pages = {189--195},
    posted-at = {2013-03-25 14:35:28},
    priority = {0},
    publisher = {ACM},
    title = {Parsing with derivatives: a functional pearl},
    url = {http://dx.doi.org/10.1145/2034574.2034801},
    volume = {46},
    year = {2011}
}

@inproceedings{felleisen:1986:cek,
    author = {Felleisen, Matthias and Friedman, Daniel P.},
    booktitle = {3rd Working Conference on the Formal Description of Programming Concepts},
    citeulike-article-id = {5906202},
    keywords = {cek},
    month = aug,
    posted-at = {2011-07-13 07:58:05},
    priority = {2},
    title = {Control operators, the {SECD}-machine, and the lambda-calculus},
    year = {1986}
}

@phdthesis{felleisen:1987:dissertation,
    author = {Felleisen, Matthias},
    citeulike-article-id = {5906226},
    keywords = {cek},
    posted-at = {2011-07-13 07:57:56},
    priority = {2},
    school = {Indiana University},
    title = {The Calculi of {Lambda-v-CS} Conversion: A Syntactic Theory of Control and State in Imperative {Higher-Order} Programming Languages},
    year = {1987}
}

@incollection{wehr:compare-modules-type-classes,
    abstract = {Researchers repeatedly observed that the module system of {ML} and the type class mechanism of Haskell are related. So far, this relationship has received little formal investigation. The work at hand fills this gap: It introduces type-preserving translations from modules to type classes and vice versa, which enable a thorough comparison of the two concepts.},
    address = {Berlin, Heidelberg},
    author = {Wehr, Stefan and Chakravarty, Manuel},
    booktitle = {Programming Languages and Systems},
    chapter = {14},
    citeulike-article-id = {4290097},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-89330-1\_14},
    citeulike-linkout-1 = {http://www.springerlink.com/content/m7v201w152h03670},
    doi = {10.1007/978-3-540-89330-1\_14},
    editor = {Ramalingam, G.},
    isbn = {978-3-540-89329-5},
    issn = {0302-9743},
    journal = {Programming Languages and Systems},
    keywords = {haskell, ml, modules, type-classes},
    pages = {188--204},
    posted-at = {2011-07-13 07:31:28},
    priority = {2},
    publisher = {Springer Berlin / Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{ML} Modules and Haskell Type Classes: A Constructive Comparison},
    url = {http://dx.doi.org/10.1007/978-3-540-89330-1\_14},
    volume = {5356},
    year = {2008}
}

@inproceedings{macqueen:modules-for-sml,
    abstract = {The functional programming language {ML} has been undergoing a thorough redesign during the past year, and the module facility described here has been proposed as part of the revised language, now called Standard {ML}. The design has three main goals: (1) to facilitate the structuring of large {ML} programs; (2) to support separate compilation and generic library units; and (3) to employ new ideas in the semantics of data types to extend the power of {ML}'s polymorphic type system. It is based on concepts inherent in the structure of {ML}, primarily the notions of a declaration, its type signature, and the environment that it denotes.},
    address = {New York, NY, USA},
    author = {MacQueen, David},
    booktitle = {Proceedings of the 1984 ACM Symposium on LISP and functional programming},
    citeulike-article-id = {1407},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=802036},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/800055.802036},
    doi = {10.1145/800055.802036},
    isbn = {0-89791-142-3},
    keywords = {ml, modules},
    location = {Austin, Texas, United States},
    pages = {198--207},
    posted-at = {2011-07-13 07:26:24},
    priority = {2},
    publisher = {ACM},
    series = {LFP '84},
    title = {Modules for standard {ML}},
    url = {http://dx.doi.org/10.1145/800055.802036},
    year = {1984}
}

@inproceedings{wadler:make-ad-hoc-poly-less-ad-hoc,
    abstract = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the  ” eqtype variables” of Standard {ML}. Type classes extend the {Hindley/Milner} polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
    address = {New York, NY, USA},
    author = {Wadler, P. and Blott, S.},
    booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {4958},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=75283},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/75277.75283},
    doi = {10.1145/75277.75283},
    isbn = {0-89791-294-2},
    keywords = {ad-hoc-polymorphism, haskell, type-classes},
    location = {Austin, Texas, United States},
    pages = {60--76},
    posted-at = {2011-07-13 06:42:42},
    priority = {2},
    publisher = {ACM},
    series = {POPL '89},
    title = {How to make ad-hoc polymorphism less ad hoc},
    url = {http://dx.doi.org/10.1145/75277.75283},
    year = {1989}
}

@inproceedings{garcia:type-classes-without-types,
    abstract = {Data-directed programs consist of collections of generic functions, functions whose underlying implementation differs depending on properties of their arguments. Scheme's flexibility lends itself to developing generic functions, but the language has some shortcomings in this regard. In particular, it lacks both facilities for conveniently extending generic functions while preserving the flexibility of ad-hoc overloading techniques and constructs for grouping related generic functions into coherent interfaces. This paper describes and discusses a mechanism, inspired by Haskell type classes, for implementing generic functions in Scheme that directly addresses the aforementioned concerns. Certain properties of Scheme, namely dynamic typing and an emphasis on block structure, have guided the design toward an end that balances structure and flexibility. We describe the system, demonstrate its function, and argue that it implements an interesting approach to polymorphism and, more specifically, overloading.},
    author = {Garcia, Ronald and Lumsdaine, A.},
    booktitle = {2005 Workshop on Scheme and Functional Programming},
    citeulike-article-id = {9540191},
    citeulike-linkout-0 = {http://repository.readscheme.org/ftp/papers/sw2005/garcia.pdf},
    keywords = {osl, scheme, type-classes},
    posted-at = {2011-07-13 05:56:27},
    priority = {2},
    title = {Type Classes Without Types},
    url = {http://repository.readscheme.org/ftp/papers/sw2005/garcia.pdf},
    year = {2005}
}

@article{costanza:dynamic-scope=aop,
    abstract = {The aspect-oriented programming community devotes lots of energy into the provision of  complex static language constructs to reason about eventual dynamic properties of a program.},
    author = {Costanza, Pascal},
    citeulike-article-id = {9540179},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.8433},
    journal = {ACM SIGPLAN Notices},
    keywords = {aspect-oriented-programming, dynamic-binding},
    pages = {29--36},
    posted-at = {2011-07-13 05:50:08},
    priority = {2},
    title = {Dynamically Scoped Functions as the Essence of {AOP}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.8433},
    volume = {38},
    year = {2003}
}

@article{dreyer:modular-type-classes,
    abstract = {{ML} modules and Haskell type classes have proven to be highly effective tools for program structuring. Modules emphasize explicit configuration of program components and the use of data abstraction. Type classes emphasize implicit program construction and ad hoc polymorphism. In this paper, we show how the implicitly-typed style of type class programming may be supported within the framework of an explicitly-typed module language by viewing type classes as a particular mode of use of modules. This view offers a harmonious integration of modules and type classes, where type class features, such as class hierarchies and associated types, arise naturally as uses of existing module-language constructs, such as module hierarchies and type components. In addition, programmers have explicit control over which type class instances are available for use by type inference in a given scope. We formalize our approach as a {Harper-Stone}-style elaboration relation, and provide a sound type inference algorithm as a guide to implementation.},
    address = {New York, NY, USA},
    author = {Dreyer, Derek and Harper, Robert and Chakravarty, Manuel M. T. and Keller, Gabriele},
    citeulike-article-id = {1256858},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1190215.1190229},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1190215.1190229},
    doi = {10.1145/1190215.1190229},
    isbn = {1595935754},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {modules, type-classes},
    month = jan,
    number = {1},
    pages = {63--70},
    posted-at = {2011-07-13 05:41:55},
    priority = {2},
    publisher = {ACM},
    title = {Modular type classes},
    url = {http://dx.doi.org/10.1145/1190215.1190229},
    volume = {42},
    year = {2007}
}

@inproceedings{garrigue:label-selective-lambda,
    abstract = {Formal calculi of record structures have recently been a focus of active research. However, scarcely anyone has studied formally the dual notion—i.e., argument-passing to functions by keywords, and its harmonization with currying. We have. Recently, we introduced the label-selective \&lgr;-calculus, a conservative extension of \&lgr;-calculus that uses a labeling of abstractions and applications to perform unordered currying. In other words, it enables some form of commutation between arguments. This improves program legibility, thanks to the presence of labels, and efficiency, thanks to argument commuting. In this paper, we propose a simply typed version of the calculus, then extend it to one with {ML}-like polymorphic types. For the latter calculus, we establish the existence of principal types and we give an algorithm to compute them. Thanks to the fact that label-selective \&lgr;-calculus is a conservative extension of \&lgr;-calculus by adding numeric labels to stand for argument positions, its polymorphic typing provides us with a keyword argument-passing extension of {ML} obviating the need of records. In this context, conventional {ML} syntax can be seen as a restriction of the more general keyword-oriented syntax limited to using only implicit positions instead of keywords.},
    address = {New York, NY, USA},
    author = {Garrigue, Jacques and A"{\i}t-Kaci, Hassan},
    booktitle = {Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {9540171},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=174434},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/174675.174434},
    doi = {10.1145/174675.174434},
    isbn = {0-89791-636-0},
    keywords = {lambda-calculus},
    location = {Portland, Oregon, United States},
    pages = {35--47},
    posted-at = {2011-07-13 05:40:29},
    priority = {3},
    publisher = {ACM},
    series = {POPL '94},
    title = {The typed polymorphic label-selective lambda-calculus},
    url = {http://dx.doi.org/10.1145/174675.174434},
    year = {1994}
}

@inproceedings{oliveira:type-classes=objects+implicits,
    abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation. This paper presents a lightweight approach to type classes in object-oriented ({OO}) languages with generics using the {CONCEPT} pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
    address = {New York, NY, USA},
    author = {Oliveira, Bruno C. and Moors, Adriaan and Odersky, Martin},
    booktitle = {Proceedings of the ACM international conference on Object oriented programming systems languages and applications},
    citeulike-article-id = {8687730},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1869459.1869489},
    citeulike-linkout-1 = {http://dblp.uni-trier.de/rec/bibtex/conf/oopsla/OliveiraMO10},
    citeulike-linkout-2 = {http://dx.doi.org/10.1145/1869459.1869489},
    doi = {10.1145/1869459.1869489},
    isbn = {978-1-4503-0203-6},
    keywords = {implicits, scala, type-classes},
    location = {Reno/Tahoe, Nevada, USA},
    pages = {341--360},
    posted-at = {2011-07-13 05:36:03},
    priority = {0},
    publisher = {ACM},
    series = {OOPSLA '10},
    title = {Type classes as objects and implicits},
    url = {http://dx.doi.org/10.1145/1869459.1869489},
    year = {2010}
}

@inproceedings{lewis:implicits=dynamic-scope+types,
    abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed {Hindley-Milner} framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use. We present implicit parameters within a small call-by-name X-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples. 1 A Scenario: Pretty Printing You have just finished writing the perfect pretty printer. It takes as input a document to be laid out, and produces a string. pretty:: Dot-> String You have done the hard part-your code is lovely, concise and modular, and your pretty printer produces output that is somehow even prettier than anything you would bother to do by hand. You're thinking: {JFP}: Functional Pearl. But, there are just a few fussy details left. For example, you were not focusing on the unimportant details, so you hard-coded the width of the display to be 78 characters. The annoying thing is that the check to see if {YOU} have exceeded the display width is buried deep within the code.... if i> = 78 then.. permission to make digital or hard copies of all or part ofthis work for {PersOXll} Or \&{SSrOOnl} {USC} is granted witllout fee provided that copies are not nn \& or distributed for prolit or commercial advantage a\$ld that copies bar this notice and the full citation on the first page. \~{}l'o {cC},py},
    author = {Lewis, Jeffrey R. and Shields, Mark B. and Meijert, Erik and Launchbury, John},
    booktitle = {In POPL'00},
    citeulike-article-id = {9540163},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.156.5131},
    keywords = {dynamic-binding, implicits},
    posted-at = {2011-07-13 05:29:57},
    priority = {0},
    title = {Implicit parameters: dynamic scoping with static types},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.156.5131},
    year = {2000}
}

@electronic{kiselyov:delimited-dynamic-binding,
    abstract = {Dynamic binding and delimited control are useful together in many settings, including Web applications, database cursors, and mobile code. We examine this pair of language features to show that the semantics of their interaction is ill-defined yet not expressive enough for these uses. We solve this open and subtle problem. We formalise a typed language {DB}+{DC} that combines a calculus {DB} of dynamic binding and a calculus {DC} of delimited control. We argue from theoretical and practical points of view that its semantics should be based on delimited dynamic binding: capturing a delimited continuation closes over part of the dynamic environment, rather than all or none of it; reinstating the captured continuation supplements the dynamic environment, rather than replacing or inheriting it. We introduce a type- and reduction-preserving translation from {DB} + {DC} to {DC}, which proves that delimited control macro-expresses dynamic binding. We use this translation to implement {DB} + {DC} in Scheme, {OCaml}, and Haskell. We extend {DB} + {DC} with mutable dynamic variables and a facility to obtain not only the latest binding of a dynamic variable but also older bindings. This facility provides for stack inspection and (more generally) folding over the execution context as an inductive data structure.},
    author = {Kiselyov, Oleg and Shan, Chung-chieh and Sabry, Amr},
    citeulike-article-id = {9540157},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8798},
    keywords = {delimited-continuations, dynamic-binding},
    posted-at = {2011-07-13 05:17:41},
    priority = {0},
    title = {Delimited Dynamic Binding},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8798},
    year = {2006}
}

