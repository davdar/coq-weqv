\documentclass{article}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage{wasysym}

\title{A Modular Monadic Framework for Abstract Interpretation (``Guts'' Draft)}
\author{David Darais}
\date{\today}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%% Abstract %%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Abstract interpretation is important.  \textit{Modular} frameworks for
\textit{deriving} computable abstract interpreters are also important. Previous
work[PLDI 2013] demonstrates a framework that unifies several concepts in
abstract interpretation through monads. However this approach lacks true
modularity, both in the space of languages and the space of analyses, and the
correctness of the approach is established (if at all) in an ad-hoc basis. This
paper demonstrated a reformulation of the monadic frameork for abstract
interpretation which is truly modular and where derived abstract interpreters
are correct by construction. The key players responsible for recovering these
qualities are a restricted class of monad transformers which are also Galois
functor transformers, and whose monadic actions are isomorphic to a space of
transitions in a pure (non-monadic) state space.
\end{abstract}

%%%%%%%%%%%%%%%%%%%% Introduction %%%%%%%%%%%%%%%%%%%%

\section{Introduction}

%%%%%%%%%%%%%%%%%%%% Overview of AI %%%%%%%%%%%%%%%%%%%%

\section{Overview of Abstract Interpretation}

%%%%%%%%%%%%%%%%%%%% Overview of Monadic AI %%%%%%%%%%%%%%%%%%%%

\section{Overview of Monadic Abstract Interpretation}

%%%%%%%%%%%%%%%%%%%% A New Approach %%%%%%%%%%%%%%%%%%%%

\section{A new approach to Monadic Abstract Interpretation}
Our approach slices the monads of the existing approach into reusable,
language-agnostic monad transformer stacks.
%
In Section ? we will establish exactly the space of monad transformers which,
given specific properties can be proven about them, will integrate seamlessly
within our framework.  For now we introduce a few familiar monad transformers
for the sake of demonstration, and defer the explanation of \textit{why} they
can be used.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
Identity     A := A
StateT   S m A := S $\to$ m (S $\times$ A)
State    S   A := StateT Identity A
Set          A := {..., A, ...}
SetT       m A := m (Set A)
\end{lstlisting}
\end{minipage}
Next, we introduce interfaces for various monadic behaviors and their laws:
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape]
Monad (m : Type -> Type) :=
  return : $\forall$ A, A $\to$ m A
  bind : $\forall$ A B, m A $\to$ (A $\to$ m B) $\to$ m B
  left_unit : bind aM ret = aM
  right_unit : bind (ret x) f = f x
  associativity : bind (bind aM f) g = bind aM ($\lambda$ x $\to$ bind (f x) g)
MonadFunctor (t : (Type -> Type) -> Type -> Type):= 
  mapMonad : $\forall$ m, Monad m -> Monad (t m)
MonadPlus m | Monad m :=
  mzero : $\forall$ A, m A 
  _<+>_ : $\forall$ A, m A -> m A -> m A
  unit : aM <+> mzero = aM
  left_zero : bind mzero f = mzero
  right_zero : bind aM ($\lambda$ x $\to$ mzero) = mzero
  associativity : (aM <+> bM) <+> cM = aM <+> (bM <+> cM)
  commutativity : aM <+> bM = bM + aM
MonadPlusFunctor t | MonadFunctor t :=
  mapMonadPlus : $\forall$ S m, MonadPlus m -> MonadPlus (t m)
MonadState (S : Type) m | Monad m :=
  getState : m S
  putState : S $\to$ m unit
MonadStateFunctor t | MonadFunctor t := 
  mapMonadState : $\forall$ S m, MonadState S m -> MonadState S (t m)
\end{lstlisting}
and prove the following lemmas:
\begin{lstlisting}[mathescape]
forall S:
  - MonadFunctor (StateT S)
  - MonadPlusFunctor (StateT S)
  - MonadStateFunctor (StateT S)
forall S and m | Monad m:
  - MonadState S (StateT S m)

MonadFunctor SetT
MonadStateFunctor SetT
$\forall$ m | Monad m:
  - MonadPlus (SetT m)
\end{lstlisting}
\end{minipage}

We define \textbf{mjoin} for transporting values from the Set monad to an
arbitrary MonadPlus:
\begin{lstlisting}[mathescape]
mjoin : forall A m | MonadPlus m, Set A -> m A
mjoin {} = mzero
mjoin {..., x, ...} = ... <+> return x <+> ...
\end{lstlisting}

\subsection{Methodology}
Languages are embedded in the framework using the following methodology:
\begin{itemize}
  \item 
  Define a \textit{single} language state space, to be used for both concrete
  and abstract interpreters.
  \item 
  Define a \textit{single} \textit{monadic} small-step function, parameterized
  by a monadic effect interface and $\delta$ function.
\end{itemize}
For example, consider the following state space for a very simple arithmetic
language:
\begin{lstlisting}[mathescape]
Int := { ... the integers ... }
Symbol := { ... x, y, etc ... }
Sign := IsZero | IsPos | IsNeg
AInt := Exact Int | Symbolic Sign
Lang := Halt Atomic 
      | LetInc Symbol Atomic Lang 
      | IfZero Atomic Lang Lang 
Atomic := Num AInt | Var Symbol
Env A B := A -> Option B
\end{lstlisting}
Notice that \textbf{Lang} is a \textit{mixed} concrete-abstract language,
potentially capable of expressing both concrete and abstract semantics.
%
In this example we will call the delta function \textbf{inc}, because it
interprets increment for atomic expressions. Given \textbf{$\langle$m,
inc$\rangle$} where:
\begin{lstlisting}[mathescape]
- Monad m
- MonadPlus m
- HasState (Env Symbol (Set AInt)) m
- inc : AInt $\to$ AInt $\to$ Set Ant
\end{lstlisting}
The semantics for the language \textbf{AInt} can be defined:
\begin{lstlisting}[mathescape]
lookup :: Symbol -> Env Symbol (dom AInt) -> m (dom AInt)
lookup x e = case e x of
  None -> mzero
  Some aD -> return aD

atomic : Atomic -> m (dom AInt)
atomic (Num n) = return (return n)
atomic (Var x) = do
  e <- getEnv
  v <- lookup x e
  return v

step : Lang -> m Lang
step (Halt a) = return (Halt a)
step (LetInc x na l) = do
  n <- mjoin (atomic na)
  r <- delta n
  modifyEnv (insert x r)
  return l
step (IfZero ca tb fb) = do
  c <- mjoin (atomic ca)
  case c of
    Exact 0 -> return tb
    Exact _ -> return fb
    Symbolic IsZero -> return tb
    Symbolic IsNeg -> return fb
    Symbolic IsPos -> return fb
\end{lstlisting}

This single semantic step function is capable of expressing both the concrete
and abstract semantics of our arithmetic language.
%
To relate our monadic function back to small-step abstract state machines we
introduce another interface which all monads in the framework must obey:
%
\begin{lstlisting}[mathescape]
MonadStateSpace m :=
  ss : Type -> Type
  transition : $\forall$ A B, (A -> m B) -> ss A -> ss B
MonadStateSpaceFunctor t :=
  mapMonadStateSpace : $\forall$ m, MonadStateSpace m -> MonadStateSpace (t m)
\end{lstlisting}
%
and we prove the following lemmas:
\begin{lstlisting}[mathescape]
$\forall$ S, MonadStateSpaceFunctor (StateT S) where 
  ss (StateT S m) A := $\text{ss}_m$ (A $\times$ S)

MonadStateSpaceFunctor SetT where
  ss (SetT m) A := $\text{ss}_m$ (Set A)
\end{lstlisting}

[transition] establishes a relationship between the space of actions in the
monad and the (pure) space of transitions on an abstract machine state space.
%
If \textbf{m} is shown to implement MonadStateSpace, then the semantics of our
language can be described as the least fixed point of iterating [transition
step] from e, i.e.:  $\llbracket e \rrbracket = \mu\; x \to e \sqcup
\text{transition}\; x$

To recover the various semantics we are interested in, the monad \textbf{m} can
then be instantiated with following monad transformer stacks:
\begin{lstlisting}[mathescape]
  m1     := EnvStateT (Env Symbol (Set AInt)) Set
  ss m1 A $\approx$ Set (A $\times$ Env Symbol (Set AInt))
  m2     := SetT (EnvState (Env Symbol (Set AInt)))
  ss m2 A $\approx$ Set A $\times$ Env Symbol (Set AInt)
\end{lstlisting}
and inc functions:
\begin{lstlisting}[mathescape]
  inc-concrete : AInt -> Set AInt
  inc-concrete (Exact n) = return (Exact (n + 1))
  inc-concrete (Symbolic IsZero) = return (Symbolic IsPos)
  inc-concrete (Symbolic IsNeg) = return (Symbolic IsNeg) 
                              <+> return (Symbolic IsZero)
  inc-concrete (Symbolic IsPos) = return (Symbolic IsPos)

  inc-abstract : AInt -> AInt -> Set AInt
  inc-abstract (Exact n) | n < -1  = return IsNeg
                         | n == -1 = return IsZero
                         | n > -1  = return IsPos
  inc-abstract (Symbolic IsZero) = return (Symbolic IsPos)
  inc-abstract (Symbolic IsNeg) = return (Symbolic IsNeg) 
                              <+> return (Symbolic IsZero)
  inc-abstract (Symbolic IsPos) = return (Symbolic IsPos)
\end{lstlisting}

When instantiated with \textbf{$\langle$m1, inc-concrete$\rangle$} a
\textit{concrete} interpreter is recovered.  When instantiated with
\textbf{$\langle$m1, inc-abstract$\rangle$} a computable \textit{abstract}
interpreter is recovered.  When instantiated with \textbf{$\langle$m2,
inc-abstract$\rangle$} a computable \textit{abstract} interpreter with
\textit{heap widening} is recovered.

%%%%%%%%%%%%%%%%%%%% Correctness Framework %%%%%%%%%%%%%%%%%%%%

\section{Correctness of the approach}

Novel in this work is the justification that a monadic approach to abstract
interpretation can produce sound and complete abstract interpreters by
construction.
%
As is traditional in abstract interpretation, we capture the soundness and
correctness of derived abstract interpreters by establishing a Galois
connections between concrete and abstract state spaces, and by proving an order
relationship between concrete and abstract transition functions.

We remind the reader of the definition of Galois connection:
\begin{lstlisting}[mathescape]
Galois (A B : Type) :=
  $\alpha$ : A $\nearrow$ B
  $\gamma$ : B $\nearrow$ B
  inverses : $\alpha \circ \gamma \sqsubseteq$ id $\sqsubseteq \gamma \circ \alpha$
\end{lstlisting}
where $A \nearrow B$ is written to mean the \textit{monotonic} function space
between A and B, namely [f : A $\nearrow$ B] means [$\exists$ f' : A $\to$ B
$\and$ $\forall$ x y, x $\sqsubseteq$ y $\to$ f x $\sqsubseteq$ f y].

% We further generalize the notion of Galois connection to the Kleisli category:
% \begin{lstlisting}[mathescape]
% KleisliGalois m A B | Monad m :=
%   $\alpha$ : A $\nearrow$ m B
%   $\gamma$ : B $\nearrow$ m A
%   inverses : $\alpha \circ \gamma \sqsubseteq$ id $\sqsubseteq \gamma \circ \alpha$
% \end{lstlisting}
% where id and $\circ$ are interpreted in the Kleisli category.
% 
% [Note why we need the Kleisli generalization.  It's related to wanting to
% distinguish between computable and non-computable functions, and finite and
% infinite sets.]
% 
% Lemma: KleisliGalois m A B $\to$ Galois (A $\nearrow$ m A) (B $\nearrow$ m B).
% %
% (This is the analogue of [Galois A B $\to$ Galois (A $\nearrow$ A) (B $nearrow$
% B)] in the traditional framework.)

Next we introducing the concept of a \textit{functorial Galois connection},
which establishes a Galois connection between functors:
\begin{lstlisting}[mathescape]
FunctorialGalois ($m_1$ $m_2$: Type -> Type) :=
  mapGalois : Galois A B -> Galois ($m_1$ A) ($m_2$ B)
GaloisTransformer (t : (Type -> Type) -> Type -> Type) :=
  liftGalois : FunctorialGalois $m_1$ $m_2$ -> FunctorialGalois (t $m_1$) (t $m_2$)
\end{lstlisting}
and we say (m : Type $\to$ Type) is a GaloisFunctor if it is proper in the
FunctorialGalois relation:
\begin{lstlisting}[mathescape]
GaloisFunctor m := FunctorialGalois m m
\end{lstlisting}

We prove the following lemmas:
\begin{lstlisting}[mathescape]
GaloisTransformer (StateT S)
GaloisTransformer SetT
GaloisFunctor Set
\end{lstlisting}

For a language $L$ and two monads $m_1$ and $m_2$, the concrete and abstract
state spaces in such a setting are $ss_{m_1} L$ and $ss_{m_2} L$, and the step
functions are (transition $step_{m_1}$) and (transition $step_{m_2}$). To
establish the relation (transition $step_{m_1}$) $\sqsubseteq$ (transition
$step_{m_2})$ we first enrich the (MonadStateSpace m) predicate to establish
an isomorphism between m and $ss_m$:
\begin{lstlisting}[mathescape]
MonadStateSpace m :=
  ss : Type -> Type
  transition : $\forall$ A B, Iso (A $\nearrow$ m B) (ss A $\nearrow$ ss B)
\end{lstlisting}
where
\begin{lstlisting}[mathescape]
Iso A B :=
  to : A $\to$ B
  from : B $\to$ A
  inverses : to $\circ$ from = id = from $\circ$ to
\end{lstlisting}

Given this stronger connection between monadic actions and their induced
state space transitions, we can now prove:
\begin{lstlisting}[mathescape]
FunctorialGalois $m_1$ $m_2$
MonadStateSpace $m_1$
MonadStateSpace $m_2$
step : $\forall$ m, L $\nearrow$ m L
----------------------------
Galois ($ss_{m_1}$ L) ($ss_{m_2}$ L)
$transition_{m_1}$ step : $ss_{m_1}$ L $\to$ $ss_{m_1}$ L
$transition_{m_2}$ step : $ss_{m_2}$ L $\to$ $ss_{m_2}$ L
$transition_{m_1}$ step $\sqsubseteq$ $transition_{m_2}$ step
\end{lstlisting}
which establishs the Galois connection between both the concrete and abstract
state spaces and interpreters interpreters induced by $m_1$ and $m_2$.
%
[... fancy diagram that sketches the proof ...]

Going back to our example, the only thing left to prove is that our step
function is monotonic.
%
Because \textbf{step} is completely generic to an underlying monad, we must
enrich \textbf{all} interfaces that we introduced in Section ? to carry
monotonic functions.
%
Generalizing these interfaces, proving that the suppliers of the interfaces
(the monad transformers) meet the monotonicity requirements, and proving that
the client of the interfaces (the step function) are all monotonic is a
systematic exercize in applying the functionality of the \_$\sqsubseteq$\_
relation.
%
We automate the proofs of such theorems using the Coq proof assistant (see
Appendix).
%
However we note that such a property can be shown to hold by construction for
all morphisms in an embedded logic (as can be done for equality) and therefore
it should come as no surprise that if all arrows are changed from $\to$ to
$\nearrow$ then everything ``just works out''.

Once it is established that our step function is monotonic, the proof burden
remains to establish [inc-concrete $\sqsubseteq$ inc-abstract]. [...]

We give a proof that heap widening is sound and less precise than heap cloning
by proving [FunctorialGalois (StateT S Set) (SetT (State S))]. [...]

Now we have an end-to-end proof that:
\begin{lstlisting}[mathescape]
$\text{transition}\; \text{step}_{\langle\text{m}_1, \text{inc-concrete}\rangle}$
$\sqsubseteq$
$\text{transition}\; \text{step}_{\langle\text{m}_1, \text{inc-abstract}\rangle}$
$\sqsubseteq$
$\text{transition}\; \text{step}_{\langle\text{m}_2, \text{inc-abstract}\rangle}$
\end{lstlisting}
or
\begin{lstlisting}[mathescape]
$\langle$concrete semantics$\rangle$
$\sqsubseteq$
$\langle$abstract semantics$\rangle$
$\sqsubseteq$
$\langle$abstract semantics w/heap widening$\rangle$
\end{lstlisting}
%
Proving this uses the facts [FunctorialGalois $m_1$ $m_2$, MonadStateSpace
$m_1$, MonadStateSpace $m_2$]--facts we get for free from the framework through
composition of monad transformers--and [inc-concrete $\sqsubseteq$
inc-abstract]--a proof obligation of the user of the framework.

%%%%%%%%%%%%%%%%%%%% Expressivity and Modularity %%%%%%%%%%%%%%%%%%%%

\section{Expressiveness and modularity}

The Abstracting Abstract Interpreters (AAI) framework developed by Might and
Van Horne provides an axis on which to develop a spectrum of analyses of
varying precision and intensional behavior.
%
The key benefit of their approach is that it generalizes to arbitrary langauges
and their state spaces.

This framework provides a separate orthogonal axis on which extensions to
abstract interpretation can be explained, and is similarly modular and language
agnostic.
%
In particular, the techniques of AAI and Monadic Abstract Interpretation can be
combined arbitrarily.

%%%%%%%%%%%%%%%%%%%% Related Work %%%%%%%%%%%%%%%%%%%%

\section{Related Work}

%%%%%%%%%%%%%%%%%%%% Future Work %%%%%%%%%%%%%%%%%%%%

\section{Future Work}

\end{document}
